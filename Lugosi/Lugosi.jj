PARSER_BEGIN(Lugosi)
import java.io.*;
import java.util.ArrayList;

class ArvoreLugosi{
  Main main;
  ArrayList<Function> functions;

  ArvoreLugosi(Main main, ArrayList<Function> functions){
    this.main = main;
    this.functions = functions;
  }
}

class Main(){
  ArrayList<Comando> comandos;
  ArrayList<VarDecl> varDecls;

  ArvoreLugosi(ArrayList<VarDecl> varDecls, ArrayList<Comando> comandos){
    this.varDecls = varDecls;
    this.comandos = comandos;
  }
}

class VarDecl{
  String tipo;
  String tokenID;

  VarDecl(String tipo, String tokenID){
    this.tipo = tipo;
    this.tokenID = tokenID;
  }
}

class Comando{}

class Atrib extends Comando{

  String tokenID;
  Exp exp;
  
  Atrib (String tokenID, Exp exp)
  {
    this.tokenID=tokenID;
    this.exp=exp;
  }
}

class ListaExp extends Exp{
  ArrayList<Exp> listaExp;

  ListaExp (ArrayList<Exp> listaExp){
    this.listaExp = listaExp;
  }
}

class ChamadaDeFuncao extends Comando{ 
  String tokenID;
  ListaExp listaExp;
  
  Atrib (String tokenID, ListaExp listaExp)
  {
    this.tokenID=tokenID;
    this.listaExp=listaExp;
  }
}

class CondicionalIF extends Comando{
  Exp exp;
  ArrayList<Comando> comandosEscopoIF;

  CondicionalIF (Exp exp, ArrayList<Comando> comandosEscopoIF){
    this.exp = exp;
    this.comandosEscopoIF = comandosEscopoIF;
  }
}

class LacoWhile extends Comando{
  Exp exp;
  ArrayList<Comando> comandosEscopoWhile;

  CondicionalIF (Exp exp, ArrayList<Comando> comandosEscopoWhile){
    this.exp = exp;
    this.comandosEscopoWhile = comandosEscopoWhile;
  }
}

class LacoDoWhile extends Comando{
  Exp exp;
  ArrayList<Comando> comandosEscopoDoWhile;

  CondicionalIF (Exp exp, ArrayList<Comando> comandosEscopoDoWhile){
    this.exp = exp;
    this.comandosEscopoDoWhile = comandosEscopoDoWhile;
  }
}
 
class Return extends Comando{
  Exp exp;

  Return (Exp exp){
    this.exp = exp;
  }
}

class Print extends Comando{

   Exp exp;
   Print(Exp exp)
   {this.exp = exp;}
}

class Exp{}

class Fator extends Exp{}

class VariavelID extends Fator{
  String tokenID;

  VariavelID(String tokenID){
    this.tokenID = tokenID;
  }  
}

class ChamadaDeFuncaoExp extends Fator{
  ChamadaDeFuncao chamadaDeFuncaoExp;

  ChamadaDeFuncaoExp(String tokenID, ListaExp listaExp){
    chamadaDeFuncaoExp = new ChamadaDeFuncaoExp(tokenID, listaExp);
  }
}

class Num extends Fator{
  float num;

  Num(float num)
  {this.num = num;}

}

class BooleanValue extends Fator{
  String trueOrFalse;

  BooleanValue(String trueOrFalse)
  {this.trueOrFalse = trueOrFalse;}
}

class Op{
  String operation;

  Op(String operation){
    this.operation = operation;
  }
} 

class Arg extends VarDecl{

  Arg(String tipo, String tokenID){
    super.VarDecl(tipo, tokenID)
  }
}

class Function{
  String tipo;
  String tokenID;
  ArrayList<Arg> listaArgs;
  ArrayList<VarDecl> varDecls;
  ArrayList<Comando> comandos;

  Function( String tipo, String tokenID,
            ArrayList<Arg> listaArgs,
            ArrayList<VarDecl> varDecls,
            ArrayList<Comando> comandos){
    this.tipo = tipo;
    this.tokenID = tokenID;
    this.listaArgs = listaArgs;
    this.varDecls = varDecls;
    this.comandos = comandos;
  }
}

  public static void main(String args[]) throws Exception{

    // abrir o arquivo passado por linha
    // de comando contendo o código em Lugosi:
    FileInputStream fs = new FileInputStream(new File(args[0]));

    // Instanciar o parser da linguagem Lugosi passando
    // como argumento o arquivo contendo o código
    //Lugosi a ser processado:
    Lugosi parser = new Lugosi(fs);

    // Chamar a primeira regra do parser que irá
    // analisar o código e devolver a árvore sintática
    ArvoreLugosi arvore =parser.Lugosi();

    // passar a árvore para o gerador de código
    // que deve gerar um arquivo .java com o mesmo
    //nome do arquivo de entrada
    geraCodigo(arvore, args[0])
}

public static void geraCodigo(ArvoreLugosi prog, String arquivo){

}


PARSER_END(Lugosi)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
  <MAIN: "main">
| <ACHAVES: "{">
| <FCHAVES: "}">
}

TOKEN: 
{
  <APAREN: "(">
| <FPAREN: ")">

| <PTOVIRGULA: ";">
| <ATRIB: ":=">
| <VIRGULA: ",">

| <ADD: "+">
| <SUB: "-">
| <MULT: "*">
| <DIV: "/">

| <AND: "&&">
| <OR: "||">

| <MENOR: "<">
| <MAIOR: ">">
| <IGUAL: "==">

| <TIPOD: "bool" | "int" | "void" | "float">

/*| <PRESV: "var" | "print" | "return" | "function" | "if" 
	| "do" | "while">*/
| <VAR: "var">
| <PRINT: "print">
| <RETURN: "return">
| <FUNCTION: "function">
| <IF: "if">
| <DO: "do">
| <WHILE: "while">

| <BVAL: "true" | "false">
}





TOKEN :
{
   <NUM : (["0"-"9"])+ ("."(["0"-"9"])+)?("E"("+"|"-")?(["0"-"9"])+)?>
 | <ID: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"])*
 ("_"(["a"-"z","A"-"Z","0"-"9"])+)*>

}



ArvoreLugosi Lugosi () :
{//Token t;
  Main main = new Main();
  ArrayList<Function> functions = new ArrayList<>();
}
{

//Syntax-directed translation Parser


// LUGOSI -> MAIN FUNC?
  Main() (Func())? <EOF> 

}

//MAIN -> "main" "{" VARDECL SEQCOMANDOS "}"
Main Main () :
{ ArrayList<VarDecl> varDecls = new ArrayList<>();
  ArrayList<Comando> comandos = new ArrayList<>();}
{

  <MAIN> <ACHAVES> VarDecl() SeqComandos() <FCHAVES> 
  {return new Main(varDecls, comandos);}
}

//VARDECL -> "var" TIPO TOKEN_id ";" VARDECL | vazio
void VarDecl () :
{}
{
//tirar recursao a esquerda
  ("var" Tipo() <ID> VarDecl() <PTOVIRGULA> VarDecl())?
}


//TIPO -> "int" | "bool" | "float" | "void"
void Tipo () :
{}
{
  <TIPOD>
}

//SEQCOMANDOS -> COMANDO SEQCOMANDOS | vazio
ArrayList<Comando> SeqComandos (ArrayList<Comando> comandos) :
{Comando comando;}
{
  (comando = Comando() {comandos.add(comando);} SeqComandos(comandos))?

  {return comandos;}
}

/*COMANDO -> TOKEN_id TOKEN_idL
| "if" "(" EXP ")" "{" SEQCOMANDOS "}" ";"
| "while" "(" EXP ")" "do" "{" SEQCOMANDOS "}"
| "do" "{" SEQCOMANDOS "}" "while" "(" EXP ")"
| "return" EXP ";"
| "print" "(" EXP ")" ";"
*/
void Comando () :
{ Token t = null; Exp e = null; Comando c = null; Comando result = null;
  ArrayList<Comando> comandos = null;}
{
  ( t = <ID> e = TokenIDL() 
  {result = new Atrib(t.image, e);}

  | "if" <APAREN> e = Exp() <FPAREN> <ACHAVES> comandos = SeqComandos() <FCHAVES> <PTOVIRGULA>
  {result = new CondicionalIF(e, comandos);}

  | "while" <APAREN> e = Exp() <FPAREN> "do" <ACHAVES> comandos = SeqComandos() <FCHAVES>
  {result = new LacoWhile(e, comandos);} 

  | "do" <ACHAVES> comandos = SeqComandos() <FCHAVES> "while" <APAREN> e = Exp() <FPAREN>
  {result = new LacoDoWhile(e, comandos);}

  | "return" e = Exp() <PTOVIRGULA>
  {result = new Return(e);}

  | "print" <APAREN> e = Exp() <FPAREN> <PTOVIRGULA> )
  {result = new Print(e);}


  {return result;}
}



//TOKEN_idL -> ":=" EXP ";" | "(" LISTAEXP? ")" ";"
Exp TokenIDL () :
{Exp e;}
{
  ( <ATRIB> e = Exp() <PTOVIRGULA> 
  | <APAREN> e = (ListaExp())? <FPAREN> <PTOVIRGULA>) 

  return e;
}

//EXP -> "(" EXP OP EXP ")" | FATOR
void Exp () :
{}
{
  ( <APAREN> Exp() Op() Exp() <FPAREN> | Fator() )
}

/*FATOR -> TOKEN_id TOKEN_idL2 
| TOKEN_numliteral | "true" | "false"
*/
void Fator () :
{}
{
  ( <ID> TokenIDL2()
  | <NUM> | <BVAL> )
}

//TOKEN_idL2 -> "(" LISTAEXP? ")" | vazio
void TokenIDL2 () :
{}
{
  ( <APAREN> (ListaExp())? <FPAREN> )?
}

//OP -> "+" | "-" | "*" | "/" | "&&" | "||" | "<" | ">" | "=="
void Op () :
{}
{
  ( <ADD> | <SUB> | <MULT> | <DIV>
  | <AND> | <OR>
  | <MENOR> | <MAIOR> | <IGUAL>)
}

//LISTAEXP -> EXP LISTAEXPL
Exp ListaExp () :
{ ArrayList<Exp> listaExp = new ArrayList<>();
  Exp e;
  }
{
  e = Exp() {listaExp.add(e);} ListaExpL(listaExp)

  {return new ListaExp(listaExp);}
}

//LISTAEXPL -> "," EXP LISTAEXPL | vazio
void ListaExpL (ArrayList<Exp> listaExp) :
{ Exp e;}
{
  ( <VIRGULA> e = Exp() {listaExp.add(e);} ListaExpL(listaExp) )?
}

//FUNC -> "function" TIPO TOKEN_id "(" LISTAARG? ")" "{" VARDECL SEQCOMANDOS "}" FUNCL
void Func () :
{}
{
  "function" <TIPOD> <ID> <APAREN> (ListaArg())? <FPAREN> <ACHAVES> VarDecl() SeqComandos() <FCHAVES> FuncL()
}

//FUNCL -> "function" TIPO TOKEN_id "(" LISTAARG? ")" "{" VARDECL SEQCOMANDOS "}" FUNCL | vazio
void FuncL () :
{}
{
  ( "function" <TIPOD> <ID> <APAREN> (ListaArg())? <FPAREN> <ACHAVES> VarDecl() SeqComandos() <FCHAVES> FuncL() )?
}

//LISTAARG -> TIPO TOKEN_id LISTAARGL
void ListaArg () :
{}
{
  <TIPOD> <ID> ListaArgL()
}

//LISTAARGL -> "," TIPO TOKEN_id LISTAARGL | vazio
void ListaArgL () :
{}
{
  ( <VIRGULA> <TIPOD> <ID> ListaArgL())?
}











